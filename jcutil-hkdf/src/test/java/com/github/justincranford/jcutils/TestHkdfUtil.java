package com.github.justincranford.jcutils;

import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.Security;
import java.util.Arrays;
import java.util.Collection;

import javax.crypto.Mac;
import javax.crypto.ShortBufferException;
import javax.xml.bind.DatatypeConverter;

import org.junit.AfterClass;
import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;

/**
 * Mandatory tests are provided using test vectors from RFC 5869.
 * Additional tests are provided for code coverage of failure use cases.
 * Together they demonstrate how the APIs are expected to work or report errors.
 */
@RunWith(Parameterized.class)
@SuppressWarnings({"static-method","hiding"})
public class TestHkdfUtil {
	private String provider;
	private int    warmups;
	private int    samples;

	public TestHkdfUtil(final String provider, final int warmups, final int samples) {
		this.provider = provider;
		this.warmups  = warmups;
		this.samples  = samples;
	}

	@Parameters(name="{index}: {0}")	// Add parameter {0} to JUnit result label. EX: "[0: SunJCE]" and "[1: BC]"
	public static Collection<Object[]> data() {	// EX: Collection.get(0)={"SunJCE",100,10000} & Collection.get(1)={"BC",100,10000}
		final int warmups = 100;
		final int samples = 1000;
		return Arrays.asList(
			new Object[][] {
				{"SunJCE",  Integer.valueOf(warmups), Integer.valueOf(samples)},
				{"BC",      Integer.valueOf(warmups), Integer.valueOf(samples)}
			}
		);
	}

	@BeforeClass
	public static void beforeClass() {
		Security.insertProviderAt(new org.bouncycastle.jce.provider.BouncyCastleProvider(), 1);
		Timer.setAutoLogInterval(0);
	}

	@AfterClass
	public static void afterClass() {
		Security.removeProvider("BC");
		Timer.logAllOrderedByName(false);
		Timer.reset();
	}

	@Test
	public void testPrivateConstructor() throws Exception {
		ValidationUtil.assertPrivateConstructorNoParameters(HkdfUtil.class, true);
	}

	/**
     * https://tools.ietf.org/html/rfc5869
     * 
     * A.1.  Test Case 1
     *	Basic test case with SHA-256
     * 
     *	Hash = SHA-256
     *	IKM  = 0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b (22 octets)
     *	salt = 0x000102030405060708090a0b0c (13 octets)
     *	info = 0xf0f1f2f3f4f5f6f7f8f9 (10 octets)
     *	L    = 42
     * 
     *	PRK  = 0x077709362c2e32df0ddc3f0dc47bba63
     *	       90b6c73bb50f9c3122ec844ad7c2b3e5 (32 octets)
     *	OKM  = 0x3cb25f25faacd57a90434f64d0362f2a
     *	       2d2d0a90cf1a5a4c5db02d56ecc4c5bf
     *	       34007208d5b887185865 (42 octets)
     * @throws Exception
     */
	@Test
	public void testHkdfAppendixATestVectorsTestCaseA1() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b");
		final byte[] salt        = DatatypeConverter.parseHexBinary("000102030405060708090a0b0c");
		final byte[] info        = DatatypeConverter.parseHexBinary("f0f1f2f3f4f5f6f7f8f9");
		final int    length      = 42;
		final byte[] expectedPrk = DatatypeConverter.parseHexBinary("077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5");
		final byte[] expectedOkm = DatatypeConverter.parseHexBinary("3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865");
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	/**
     * A.2.  Test Case 2
     * 
     *	Test with SHA-256 and longer inputs/outputs
     * 
     *	Hash = SHA-256
     *	IKM  = 0x000102030405060708090a0b0c0d0e0f
     *	       101112131415161718191a1b1c1d1e1f
     *	       202122232425262728292a2b2c2d2e2f
     *	       303132333435363738393a3b3c3d3e3f
     *	       404142434445464748494a4b4c4d4e4f (80 octets)
     *	salt = 0x606162636465666768696a6b6c6d6e6f
     *	       707172737475767778797a7b7c7d7e7f
     *	       808182838485868788898a8b8c8d8e8f
     *	       909192939495969798999a9b9c9d9e9f
     *	       a0a1a2a3a4a5a6a7a8a9aaabacadaeaf (80 octets)
     *	info = 0xb0b1b2b3b4b5b6b7b8b9babbbcbdbebf
     *	       c0c1c2c3c4c5c6c7c8c9cacbcccdcecf
     *	       d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
     *	       e0e1e2e3e4e5e6e7e8e9eaebecedeeef
     *	       f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff (80 octets)
     *	L    = 82
     * 
     *	PRK  = 0x06a6b88c5853361a06104c9ceb35b45c
     *	       ef760014904671014a193f40c15fc244 (32 octets)
     *	OKM  = 0xb11e398dc80327a1c8e7f78c596a4934
     *	       4f012eda2d4efad8a050cc4c19afa97c
     *	       59045a99cac7827271cb41c65e590e09
     *	       da3275600c2f09b8367793a9aca3db71
     *	       cc30c58179ec3e87c14c01d5c1f3434f
     *	       1d87 (82 octets)
     */
	@Test
	public void testHkdfAppendixATestVectorsTestCaseA2() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f");
		final byte[] salt        = DatatypeConverter.parseHexBinary("606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeaf");
		final byte[] info        = DatatypeConverter.parseHexBinary("b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff");
		final int    length      = 82;
		final byte[] expectedPrk = DatatypeConverter.parseHexBinary("06a6b88c5853361a06104c9ceb35b45cef760014904671014a193f40c15fc244");
		final byte[] expectedOkm = DatatypeConverter.parseHexBinary("b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19afa97c59045a99cac7827271cb41c65e590e09da3275600c2f09b8367793a9aca3db71cc30c58179ec3e87c14c01d5c1f3434f1d87");
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	/**
     * A.3.  Test Case 3
     * 
     *	Test with SHA-256 and zero-length salt/info
     * 
     *	Hash = SHA-256
     *	IKM  = 0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b (22 octets)
     *	salt = (0 octets)
     *	info = (0 octets)
     *	L    = 42
     * 
     *	PRK  = 0x19ef24a32c717b167f33a91d6f648bdf
     *	       96596776afdb6377ac434c1c293ccb04 (32 octets)
     *	OKM  = 0x8da4e775a563c18f715f802a063c5a31
     *	       b8a11f5c5ee1879ec3454e5f3c738d2d
     *	       9d201395faa4b61a96c8 (42 octets)
     */
	@Test
	public void testHkdfAppendixATestVectorsTestCaseA3() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b");
		final byte[] salt        = DatatypeConverter.parseHexBinary("");
		final byte[] info        = DatatypeConverter.parseHexBinary("");
		final int    length      = 42;
		final byte[] expectedPrk = DatatypeConverter.parseHexBinary("19ef24a32c717b167f33a91d6f648bdf96596776afdb6377ac434c1c293ccb04");
		final byte[] expectedOkm = DatatypeConverter.parseHexBinary("8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d9d201395faa4b61a96c8");
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	/**
     * A.4.  Test Case 4
     * 
     *	Basic test case with SHA-1
     * 
     *	Hash = SHA-1
     *	IKM  = 0x0b0b0b0b0b0b0b0b0b0b0b (11 octets)
     *	salt = 0x000102030405060708090a0b0c (13 octets)
     *	info = 0xf0f1f2f3f4f5f6f7f8f9 (10 octets)
     *	L    = 42
     * 
     *	PRK  = 0x9b6c18c432a7bf8f0e71c8eb88f4b30baa2ba243 (20 octets)
     *	OKM  = 0x085a01ea1b10f36933068b56efa5ad81
     *	       a4f14b822f5b091568a9cdd4f155fda2
     *	       c22e422478d305f3f896
     */
	@Test
	public void testHkdfAppendixATestVectorsTestCaseA4() throws Exception {
		final String hash        = "HmacSHA1";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("0b0b0b0b0b0b0b0b0b0b0b");
		final byte[] salt        = DatatypeConverter.parseHexBinary("000102030405060708090a0b0c");
		final byte[] info        = DatatypeConverter.parseHexBinary("f0f1f2f3f4f5f6f7f8f9");
		final int    length      = 42;
		final byte[] expectedPrk = DatatypeConverter.parseHexBinary("9b6c18c432a7bf8f0e71c8eb88f4b30baa2ba243");
		final byte[] expectedOkm = DatatypeConverter.parseHexBinary("085a01ea1b10f36933068b56efa5ad81a4f14b822f5b091568a9cdd4f155fda2c22e422478d305f3f896");
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	/**
     * A.5.  Test Case 5
     * 
     *	Test with SHA-1 and longer inputs/outputs
     * 
     *	Hash = SHA-1
     *	IKM  = 0x000102030405060708090a0b0c0d0e0f
     *	       101112131415161718191a1b1c1d1e1f
     *	       202122232425262728292a2b2c2d2e2f
     *	       303132333435363738393a3b3c3d3e3f
     *	       404142434445464748494a4b4c4d4e4f (80 octets)
     *	salt = 0x606162636465666768696a6b6c6d6e6f
     *	       707172737475767778797a7b7c7d7e7f
     *	       808182838485868788898a8b8c8d8e8f
     *	       909192939495969798999a9b9c9d9e9f
     *	       a0a1a2a3a4a5a6a7a8a9aaabacadaeaf (80 octets)
     *	info = 0xb0b1b2b3b4b5b6b7b8b9babbbcbdbebf
     *	       c0c1c2c3c4c5c6c7c8c9cacbcccdcecf
     *	       d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
     *	       e0e1e2e3e4e5e6e7e8e9eaebecedeeef
     *	       f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff (80 octets)
     *	L    = 82
     * 
     *	PRK  = 0x8adae09a2a307059478d309b26c4115a224cfaf6 (20 octets)
     *	OKM  = 0x0bd770a74d1160f7c9f12cd5912a06eb
     *	       ff6adcae899d92191fe4305673ba2ffe
     *	       8fa3f1a4e5ad79f3f334b3b202b2173c
     *	       486ea37ce3d397ed034c7f9dfeb15c5e
     *	       927336d0441f4c4300e2cff0d0900b52
     *	       d3b4 (82 octets)
     */
	@Test
	public void testHkdfAppendixATestVectorsTestCaseA5() throws Exception {
		final String hash        = "HmacSHA1";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f");
		final byte[] salt        = DatatypeConverter.parseHexBinary("606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeaf");
		final byte[] info        = DatatypeConverter.parseHexBinary("b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff");
		final int    length      = 82;
		final byte[] expectedPrk = DatatypeConverter.parseHexBinary("8adae09a2a307059478d309b26c4115a224cfaf6");
		final byte[] expectedOkm = DatatypeConverter.parseHexBinary("0bd770a74d1160f7c9f12cd5912a06ebff6adcae899d92191fe4305673ba2ffe8fa3f1a4e5ad79f3f334b3b202b2173c486ea37ce3d397ed034c7f9dfeb15c5e927336d0441f4c4300e2cff0d0900b52d3b4");
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	/**
     * A.6.  Test Case 6
     * 
     *	Test with SHA-1 and zero-length salt/info
     * 
     *	Hash = SHA-1
     *	IKM  = 0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b (22 octets)
     *	salt = (0 octets)
     *	info = (0 octets)
     *	L    = 42
     * 
     *	PRK  = 0xda8c8a73c7fa77288ec6f5e7c297786aa0d32d01 (20 octets)
     *	OKM  = 0x0ac1af7002b3d761d1e55298da9d0506
     *	       b9ae52057220a306e07b6b87e8df21d0
     *	       ea00033de03984d34918 (42 octets)
     */
	@Test
	public void testHkdfAppendixATestVectorsTestCaseA6() throws Exception {
		final String hash        = "HmacSHA1";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b");
		final byte[] salt        = DatatypeConverter.parseHexBinary("");
		final byte[] info        = DatatypeConverter.parseHexBinary("");
		final int    length      = 42;
		final byte[] expectedPrk = DatatypeConverter.parseHexBinary("da8c8a73c7fa77288ec6f5e7c297786aa0d32d01");
		final byte[] expectedOkm = DatatypeConverter.parseHexBinary("0ac1af7002b3d761d1e55298da9d0506b9ae52057220a306e07b6b87e8df21d0ea00033de03984d34918");
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	/**
     * A.7.  Test Case 7
     * 
     *	Test with SHA-1, salt not provided (defaults to HashLen zero octets),
     *	zero-length info
     * 
     *	Hash = SHA-1
     *	IKM  = 0x0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c (22 octets)
     *	salt = not provided (defaults to HashLen zero octets)
     *	info = (0 octets)
     *	L    = 42
     * 
     *	PRK  = 0x2adccada18779e7c2077ad2eb19d3f3e731385dd (20 octets)
     *	OKM  = 0x2c91117204d745f3500d636a62f64f0a
     *	       b3bae548aa53d423b0d1f27ebba6f5e5
     *	       673a081d70cce7acfc48 (42 octets)
     */
	@Test
	public void testHkdfAppendixATestVectorsTestCaseA7() throws Exception {
		final String hash        = "HmacSHA1";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c");
		final byte[] salt        = DatatypeConverter.parseHexBinary("");
		final byte[] info        = DatatypeConverter.parseHexBinary("");
		final int    length      = 42;
		final byte[] expectedPrk = DatatypeConverter.parseHexBinary("2adccada18779e7c2077ad2eb19d3f3e731385dd");
		final byte[] expectedOkm = DatatypeConverter.parseHexBinary("2c91117204d745f3500d636a62f64f0ab3bae548aa53d423b0d1f27ebba6f5e5673a081d70cce7acfc48");
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test(expected=IllegalArgumentException.class)
	public void testHkdfNullProvider() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("00");
		final byte[] salt        = DatatypeConverter.parseHexBinary("00");
		final byte[] info        = DatatypeConverter.parseHexBinary("00");
		final int    length      = 42;
		final byte[] expectedPrk = null;
		final byte[] expectedOkm = null;
		this.testHkdfHelper(null, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test(expected=NoSuchProviderException.class)
	public void testHkdfUnknownProvider() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("00");
		final byte[] salt        = DatatypeConverter.parseHexBinary("00");
		final byte[] info        = DatatypeConverter.parseHexBinary("00");
		final int    length      = 42;
		final byte[] expectedPrk = null;
		final byte[] expectedOkm = null;
		this.testHkdfHelper("UnknownProvider", hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test(expected=NullPointerException.class)
	public void testHkdfNullAlgorithm() throws Exception {
		final String hash        = null;
		final byte[] ikm         = DatatypeConverter.parseHexBinary("00");
		final byte[] salt        = DatatypeConverter.parseHexBinary("00");
		final byte[] info        = DatatypeConverter.parseHexBinary("00");
		final int    length      = 42;
		final byte[] expectedPrk = null;
		final byte[] expectedOkm = null;
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test(expected=NoSuchAlgorithmException.class)
	public void testHkdfEmptyAlgorithm() throws Exception {
		final String hash        = "";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("00");
		final byte[] salt        = DatatypeConverter.parseHexBinary("00");
		final byte[] info        = DatatypeConverter.parseHexBinary("00");
		final int    length      = 42;
		final byte[] expectedPrk = null;
		final byte[] expectedOkm = null;
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test(expected=IllegalArgumentException.class)
	public void testHkdfNullIkm() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = null;
		final byte[] salt        = DatatypeConverter.parseHexBinary("00");
		final byte[] info        = DatatypeConverter.parseHexBinary("00");
		final int    length      = 42;
		final byte[] expectedPrk = null;
		final byte[] expectedOkm = null;
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test(expected=IllegalArgumentException.class)
	public void testHkdfEmptyIkm() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("");
		final byte[] salt        = DatatypeConverter.parseHexBinary("00");
		final byte[] info        = DatatypeConverter.parseHexBinary("00");
		final int    length      = 42;
		final byte[] expectedPrk = null;
		final byte[] expectedOkm = null;
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test
	public void testHkdfNullSalt() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("00");
		final byte[] salt        = null;
		final byte[] info        = DatatypeConverter.parseHexBinary("00");
		final int    length      = 42;
		final byte[] expectedPrk = DatatypeConverter.parseHexBinary("6620B31F2924B8C01547745F41825D322336F83EBB13D723678789D554D8A3EF");
		final byte[] expectedOkm = DatatypeConverter.parseHexBinary("06BACBA013A57E9DD186931647DC90E7F0C8CA4D9602BDE594014CE11ACAEC7421640591F3DFEE3A67E8");
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test
	public void testHkdfEmptySalt() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("00");
		final byte[] salt        = DatatypeConverter.parseHexBinary("");
		final byte[] info        = DatatypeConverter.parseHexBinary("00");
		final int    length      = 42;
		final byte[] expectedPrk = DatatypeConverter.parseHexBinary("6620B31F2924B8C01547745F41825D322336F83EBB13D723678789D554D8A3EF");
		final byte[] expectedOkm = DatatypeConverter.parseHexBinary("06BACBA013A57E9DD186931647DC90E7F0C8CA4D9602BDE594014CE11ACAEC7421640591F3DFEE3A67E8");
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test
	public void testHkdfNullInfo() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("00");
		final byte[] salt        = DatatypeConverter.parseHexBinary("00");
		final byte[] info        = null;
		final int    length      = 42;
		final byte[] expectedPrk = DatatypeConverter.parseHexBinary("6620B31F2924B8C01547745F41825D322336F83EBB13D723678789D554D8A3EF");
		final byte[] expectedOkm = DatatypeConverter.parseHexBinary("CA0D09522019F6622A278DB5E2A2131A52A626A7478B2551BDE9A42B090E02FAD05E22BA6290969E0299");
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test
	public void testHkdfEmptyInfo() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("00");
		final byte[] salt        = DatatypeConverter.parseHexBinary("00");
		final byte[] info        = DatatypeConverter.parseHexBinary("");
		final int    length      = 42;
		final byte[] expectedPrk = DatatypeConverter.parseHexBinary("6620B31F2924B8C01547745F41825D322336F83EBB13D723678789D554D8A3EF");
		final byte[] expectedOkm = DatatypeConverter.parseHexBinary("CA0D09522019F6622A278DB5E2A2131A52A626A7478B2551BDE9A42B090E02FAD05E22BA6290969E0299");
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test(expected=IllegalArgumentException.class)
	public void testHkdfNegativeLength() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("00");
		final byte[] salt        = DatatypeConverter.parseHexBinary("00");
		final byte[] info        = DatatypeConverter.parseHexBinary("00");
		final int    length      = -1;
		final byte[] expectedPrk = null;
		final byte[] expectedOkm = null;
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test(expected=IllegalArgumentException.class)
	public void testHkdfZeroLength() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("00");
		final byte[] salt        = DatatypeConverter.parseHexBinary("00");
		final byte[] info        = DatatypeConverter.parseHexBinary("00");
		final int    length      = 0;
		final byte[] expectedPrk = null;
		final byte[] expectedOkm = null;
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test
	public void testHkdfMaxLength() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("00");
		final byte[] salt        = DatatypeConverter.parseHexBinary("00");
		final byte[] info        = DatatypeConverter.parseHexBinary("00");
		final int    length      = Mac.getInstance(hash, this.provider).getMacLength() * 255;
		final byte[] expectedPrk = DatatypeConverter.parseHexBinary("6620B31F2924B8C01547745F41825D322336F83EBB13D723678789D554D8A3EF");
		final byte[] expectedOkm = DatatypeConverter.parseHexBinary("06BACBA013A57E9DD186931647DC90E7F0C8CA4D9602BDE594014CE11ACAEC7421640591F3DFEE3A67E8280DD6F1F7A26B7F6B4ACC80235DE98BC1FC984EEA32CE0B8029007AD9980B13CDABB441ABE04B26B881E531F07748B8E4F0649085CE9B76D79706D6F3CAE2478ADF2A8817D3C3196312654CD577CB8E3C01CD950D95EA85FD4E3E9B35C024DCE4E56B8B51A6CA0D381347EF55066E2952C14FF7206567983A4F4E3D57DBD357D55CD3A2FC6FE67583097EA82BACDA39CECAD0E2996A1067D0B68846254914F98C0E5FEC6A3CDC94F60BC017A21D5E1ABED05FC8917CB238ECFA021BA2FEF252CA77E3E9E5B6AB91F97FD9501AAFF1EC09CD4FD20784DFB6ECCF988B2E1FC463D824558726A5541F3A041FE8118970AEC0787FF36A909B0BE3BB43E2342687DAC96B564E0BFE49724601C8D2BBBA2611BC991CB61AB697FF124923833FF43503C3A1A0A1915F76591AA79222D5400C6FE4B0C7048936A091834B02822C0139507D458E6DD69171E7BD03678337D8F17E402C5B369CD7AA9C441713A617D50723F638A8C2C3FCA940FE0A3C8D18ED4434E04ABA44BA1FA89F1CD02CFCB265A6329AA04EF3680BC96D7788C79C8803637E3A6E961BD7A4979E1F81262EF8183C82CC5382A3577DAE9DF195BA4E02868ACA163FD9A4400177D123B992DB474FE05723B929DC1C8545C95FC2B33194B5BDB7AC370249D7BBE012EEB4DAC2618607D77B7316C966C02836566C4D6A0B9AB91378098A0F66976EBF76BB2929A46C7CC484F8FFECBDCCC4ADAABB7DB1BF687ADF65357852DDABD452F50AE9801B5A8B37908F2CF651C0546DDE6F029AC981C8388D5720E55D738074C6E07A0C546FA7303363A3073F314318E9A24CB2EBCF85AEA2B44866A5085A5E4C39B5AB7BB9410033EC9E18814C3DFEB0DA2322B467F9978C319D927A1E4C4531FEEE4881D5E9B22C60E0F4661859F8DF6FCA8BC576891DC5FF80B4D0210085AEB4DB7D2397B6C1B962D23986C0AAAA86C1B55800F75DDF5B5DF5F7AA454903ABE9498669876E0F11122462D859F5675F6EFEC650B6703DAC61B26F21AAB0BBF826732B227702AD5D1797F102ADF13B9564BD973CA8D0E117C9F4AD24CD992A172CC7B4680B0179ACC86F2E29AC5740DC28ED0E555D1559C617B097A417613A6E8BED213422ED16BE64819D7E9C5A62F81C612D72D5D5406EC33E0EBBDCD17D09053ADE94D6D69313B27D74DB504FA53970FBA8B56D782B4C287BB8540420C65B5D3ABD0B98655AAF59DCF72137BD59BBF79530E3963A75E2D0FB724A1083CE5CF2BD026D2EDEDD57F4DE05732FC9FA905F30F84FB99B520ABEDAB32BCB92EB3C8381E68029541E923833DC24D1CB658D51B5EFB7864EF7DF0E807BC1FC85993A5150B3AAD8F28589BEF062E8B614E03622137A0522F36EAD4DA564986C7FF543E59D667FF08F07BBFE077D2FAF039AAF4051A52318DF8D757BF5888D4ACC855F3AB409C56960E0DB8F5A6CA61AB078D1AD51E0704472E488C4859C9E7AC7FB164FC62E1FDEAD9AFF9E8A2E479E070951B53F90DDA979C1BDD452C011B152F4D121E341D06699F4F3E3AEB223B1B5AA669CA82885F330D065E7407A4CF3DFA2211AD2A07C52124393A1AF325A5002D9AAF3D8894B1F825175DE00AF0D0B9D9D7458BB03F2FA37B9453724670245B7E45056AC0150D449815FBA9AD3EC7F79737F5268501478EC088D5A9BE28A7F71FA8068922395B39FA334C1CB3432BF435847B28A8262E240F5D67087739C2AE2065F9D642BFF18C3E76E07287A01B075084A88B7908BB5CD390E8FD760BEFB56CBEDC07A21283DFF4021F24D65BF8ACD9E60CE4147D3CB17E39BD7B1D20E1C0751F9ACD13AB0B7F0404AB5C7B96AD2DCAA32662EEE2738B4497AB6016FB6667724404172B2A73903476A415564562C1A9081EE712A28C6BC64AD27B40C8438ED1CDDF73FB33772820A4A612FBA71DAE1DEC70388D9D95A8F23039B9B94AA521BF32E8496958E4873C40B543B2435DCE056919D57FC7649C244F1CC3A6A6622214C8A16A3C84785F300AA5E601AC51CE198DB3F8A6BAED89BD04C9069DE1325C69391FA986B4DEC2D4F14D83F1EBDB23F287FACF453C62D82E829575BB1357F768DEEEEB3CF37A0DF9291AB7112DF5EA628AB25EE3889D0B7F183D31363BEEF20AA2BF45A28EF6DA441CA1931D383D972A4A92274E6587ED77B3AB778C36A9EC7B2052BF702CAF8B67421E4F23928FE695642BBC6E2390B8EA51DBAE95733037BF9019BD90AB3A12A6BC1FEEAC47DE690F99CB567CCDD42CD3882801CC1433086803B17CF2487831BDF0C1D1FC0D42706A21DE392D085692DD46F54E7BBABD7E2425AF146414FEE0717C34DD543266345BBC9A119B7F5E4DAD3CF5F2C92874E9BA42DD9D2D5370859D7BBF227B288D453F458E2B5F4BDE69685E4DD2D8F30FDAD40404472CB8D1F73BDF1D0925AEC735884A0CE3D9210D7CDA0F5E900646E05F727B2113B8FCEF0F9FE80B679DFFF9A065B2700F1413A05218FB587820B90C593AB7778A056E97255A12DBFCFB168BC124ADCAC48A1C98C9D4D6D07C622BBC9435B7D665FAC37D2340661A1E02D473D99F7E0425C21AF9457C00715D01B241EAFBDE093662B0FC8636F78EF96F2D04D37D9BF9B6EC80291CA8439182A2EE46DC47BE5777A4AB65183951CB65B776E8382B4C25CBA9905F51EA41ABD214698E88D097BD03FEEA447307DB22EC2458AAF32F227327EDF9BCEB78645027D47B8D8BD157B66A4270EC1DFA5F2365014084D8DC1C8A179FD4B053E0BCD4C455D76E975F8A410455EC672BBB72D1702C40A46762A32845007D50E3C800FA451EF33B3CDDF9AA9C904A05F31CDAD99246BA21219DA304F29E92477052563DFF4B950529415712025B5561D83F7C3E6AB1FF415FA562E54D2B6D663E956FCAC531374C0290E06B3C7AA1E99D756D45002D44AA9E40DF50D61C682EC7BB99FFF28F43EFEF75BF124DF1277993B6568477292728A02C62AF67CDA00EA120452B2BD9DB34A0D80E4D5AA3EE3F78DEEDD4582409AB81ECF3D5A51013EA77447AAD4FB49C264EFC8014D54B2696C6C9F3AFC0F5092245C4F395917A9AD0AE335415F95BDC81A8A2CB3E026F7E08191F90FB21988AA38F3198E6ADA402B546C0E3D476064F16AA418EC3343CA6EB95D3AE563159FA7919218041C5980852B41CDB52F46DCCBF0BF2BF71738D7BF79E9D8EC5D3A8453B84702DEE91EB0F50E071BBB533DD0101CC54B8AC6C5F89F592F8160EDD49FAD7DE5F850FFBA1C97844977CC10B8E63B7B8F077015BFC86C8F00D568D7BD70EBD153A41C1B5D3C237EB8EC9CC729A447A35AABE517E24CF376006253A30BEE81EA7B3628AAA5700608B8935A8B98D254A6B42384E392CA9FD341A094D86EE38B618CACFB9ADC3687A4532FA953CFB52DDA412009CAA773FE0DE009606C1AACC93816023231090648922985BB736599F3391664FBE1CD10104124A36DEF42842126782ACB230F6E54F7AF9FFC6E26E3C112B3C96EE5F6A4873CAD0845E1129DCF73C224E7FF89C7C76187E1B066ECD163B6984B48E60EBCD64A022521E1E5E9FE3BB995E5551D718FD7E1FC3CAD5CCDACE39664AD3F3E2516081A869EC5B54BDE87B6A42CB0415108A35164E189FF24E995A1C1A272E831C5C325D5C45FD2B74CF3D00039F53865CCAFE37663E499E432CF4BCE937302183B99B43801148FD525915A576F20CB9B2CEC632451DA3B6E1D57F179D9904991728987F5648C15573A4C51504562BA1D31AF3B55AD34B6551451D41019CA6E5B6277B50FFF1B623428BDD749ECD028847DBEED3D45ECD6FF212D0EC1B121C94E56D722EC3CE4D2EAD603A248A0085E086785EA59942B89D2F913358990E7C4968C838D1DD40BE30BE374EFC3C69E24178DCFCE1817F72C7BE867666ED32DC9F31098A30453DA4F2F137F8539C52DE325152B0AC27ECE86B8CE7604AEEA1AC16D7CAD8E63EC46F5462BF11369E89EECDFA920E7731FE043EF6ADA6ADABDCC5DC565757B9161E9A77F63C958FEF83FA21F05440771430ACC944D388F519981032B132FF582E507F6FA951C90AC0D43098C237DEF81CF40A24D29C6FA0ABD86F50DB7347B5AAAB058F1F1FDDA3627A1DB7F517C54867DCC31F2BCD44256F4673BC05F2C1973CF0B0CCE3680E98E497C5FB8354BD54377525FB5423C76CF1AD8E0E731124B75521B6C3139131CB80B3687DB7F4D2D4AA521A3ECE4831B1C25D443E8524B7FD0CB92D9DB62E0D7E33AF925514CB2E5E4F6BF438C2CF6CD16BB99607FB2C1912EBF3913F894A3AFFB2682DEC2A6AC56D309404072EA696B9673EC8927C9549521FB75B381C12E60701C9C9AF79A920E8DDF75B9282CF98864FA6A1174C0D2187A793E6465AF5D02736EBDA8D75D3EAFF2F6F41E2DD971A126371AF8B5AD0E413DC2AF7D07C6977FA50FADE46AE861EF38D76808426CD20DCAC662CC32F804325BFD5EFF02063A82ACC1BF5D15C9CF4D3EA688C8DD9985016B1CBED62D12FE0AC1F698EAC113752684CE9287BA6ED6C31CC6F47B104166E2F7542A7E8DAAA37D8664898F88A8D36A8CDF795A964C3803C9605F6760C2773ECE7719C1E5061B2728C1D6A3DD26E2C298C664EE9CD4188494648BA3C16431A4F6812C42DB2C7BFA3F75BFABBA20B1C0EC6D56C0070EF4ED1531A0E87A67B91DAEB833250C3A770987FEF3970ECC63767F8814AFEBF2A9B0FC864C23C4AB7B9B3889C7642DD6DD39FDC35528AC381824BD460CA29B92500F62CABBE21392FD31D290EAB771C836650399E785EFA05E768BC4449E29CBAAD224365BA267BA60E4EC1F7FFDEC586924782A7B852FA7562DAC9DFB5305ED448C20CACCBC6DF2CDC395BDFEE8B10EBD2BB2F87F5B62CCBF148F87DD48C109B851F351007DCA70BC66FB5B06B6C81F990C54218DB23B31B136394D21D29F7837C63264E29FB40A82A57148A5F5B46048FCA4BF0D04F57160C279FC51CD299883B3F9DC336605C1F1DDD08697E9EBBE30A676B05597A027171CC4549F64730B86795E6B8A5FD5F4B5C0BDA812C8C512460FCDE3E5A0B3336993B78861CC71D5F56F20259B920EC8E4B6CD34F5394D982DCE7B100E06DE5280DBA879E840FA63EDCF5E98ACDFCCF1E7B08ED7838B771CC1AC81C302B185B8E9DCF3C7A6F001C0B7A99D49E3B8903965CC7198B9BE92E6349157B054007BE3DB4BA943CC6036637463AC1734C5D77F2320792221978E18E3B5B0EBFCD66759176952A0B65F8ED8FF6F5D16822CFD451E28AD3ABF3C0BD3D583DCD2F49A3D6E5100F25298F93865F7080F3AFC078479612C44B88F7921496168668F27AF2B8D0D4CD310C5055FB2439A5A1078DB49F3BEBFA4B41F2485286D9F55B85B38E2B2CF6E3693DE793447222BC384645CC28BAA74DC6489FB595350D118E5CC15EE7B8F78E80CCB2ACE34034D9F03F9A00815BD18FBE5F9F2FAC604D3E521411B7550CC45968AC5F20AFA5256F409CF685023A4E939E3F22AAAFE9B52142939D34E3FD6C767FB94D0F409593E369871205C340C59A8B3E1131B1B649D4211420AA7BEE71EAD3491B0453EF2D466BAA0D5CABC63607467A796CD170F92F9B990F42653C010684EC7EF553EBB20260E71D3D440266C8F444F77F928E1200377286853DF9A218C108A05420FAF8D24EA7641288FDCEF5028069F31C074A3374199191890009CF8B89629804F05F4747F90C8F16F50D904AB9116876EFCD487F6946540272A39C4AC483C058026CEDD4B6836FED124F2E6A618F105852AB074A9A2D8BB8314A6D5E4CC4AAAFE07F0E15FA39BCDBD10E453707D516C77BA8F4D3804A352221ED8BC3112DF169844420C59DB0D08A5168D343C1DABA42D2F193248805C4D0C3B544FA6D6FBCC60513885B859B523CF024DB5C16BF30151EBFEA75D9394A0EBB861F180BD04FDAD99A3E790E171056036FD3C521F154205CF337364316AC65DB1D159EEE63E196265B0AB59FAD9631E5439F5881808D05C3F977FC5C6B90029B78988E3C97D9A0E3CC210552DA2263ED0F3830349FC4039BA71148230ED7AB1787DC00951F52E06B36150643B5B2730A0129DB2592FAE58F7030B86D69ED4DFE0C2D45EE108DB717CA4BAD066D562389FD511CC92DCCF6E05BB5F35252AC373F55C98C7C5CEB06491E5C737AA89461D17748F9F9B0441935D402E2549381A19B38731CF015682516E31669BAC076DD14FFCAA176C8337B998D02A382A5EC693F99D726967D1E8015A122F9C6A46925982B0140919378A6B3426C2A2F97C79AB3F84632028C3EB2C940B46A2008C7E89640D062ED5045D1178BD75875D4629DF0DFC33B45B063A992FF1CF4AB6417B85882ACC25D116F39EF80B9650C8F724F567904C232AB4DBB2104C803438832F02D31AAF403F3E6A872F2398823F4B9C4682A5FBBD90F5CAA4F4B7ECEA7C3F6511EEC1DE1C4CEC5FC65145E75E72C35FCC4D46C196A412443BC4606D656AFD36276757D0E837BF2F893DF29EEE9A70C86A354DED941A3205854288C80C7451F073B7F02B742061D1E07C2FB3F67D8B39D7EAE2FC851D6D7C9D526ECEC50C6516C9B95686FD7279AE91D99EFA25E89ABD6DF2A7B32072F9B67A3372563A3CA2696E0F6F6CB5A8A2DFD3B3085C600F23B94024D79B69A2B7BFBB6440E90119225DB616794026B0A14C24033161FBDEE95662AA05DB7A25F63CC0513A30E978338FC953D177CFD308371004F0AAA3407D8388F185E423D67F5ACE87DDB2AFD3D3702E33A086B45FE78921EFC7E834716856C7AA46D6C887C2A091B37AE07F279884DF05F433D8828103410530BEC3592B4F83242771905DFFA10F57FA47B6746EC2FCF9CCB0059B9AF655EE9061FA02E9A8E7512CD6A4D185BFC171D0AAC045CE3E27ECD5BCA8EC9E9EE06AD5B0EEE55059FBFD19A5E36B436916FB81AD8B8755CAB1A8CD8396125D36021770727268A5705C4EFF8C4B9147E1A7DD760F9695F9888E11561F154B977E4CE0E4D8652CFCC7786FBA9BE73C8B7BFCADE4C516DE236DCB7154B18CB8FB1A25096D5176F835D6F68959F0421C1C2218F0B1872B7B8D381B75E9449BC69DD81E2113CE8775B54991D2356440212802986825ED34774150F157162A8E44BFEEBE993D9ED391899DC7ED963859E7AB6D79077C825F54BADB31D6E95F874A482C0A066708DEB0012CCC0E69361A50EAC4EAD8C5050EE0514E1B08D83D164AA418070319B86A3785DB2CCABAE19B03AD843776C72F8C89697CFBD4BF958ABB16E2E24F5DE6178774A44D166A756775002016EF2C97E79C54797B20F187C3163F8B62886244D808529CCFAC5B2E54FF8BD98286071CD36F6F4F1D4E8DCB3D69F23414CC562B6D286F99A7BAD8AF8A05F73899626CDB14410E70AE739830C497EE6521FB016D38FC60B1367976B8D23C3D8E87372BD597200F95CB71ABF24A34E90099431638CBB4279A4CF4CCD0062C359E5E1E7D4DC988C00D2FCA2F7F04DB48AD56788E5DD9909E0B8A21EC6F952315BFFDFEA42195C8B77582F72DD4AA713C10946D6C49D1BFA05591BC824785DE86802C17C4560CCFA675E1EA57C16CAC60208886EE6F008D8C4B0A7CF43B56599DB14B80B872514B931B1771097292618DCE96C666FB63E3D4F7651C870B6D0AA54E315D9E1EE5B786CAA4337A54D1241D824CAD5CF1AF1CC42F005C710AFE25F24B017A72B73F0975EDA7B84529DE49D035355D486DE2E0C62E0D609E659AF856D0330178A54AD1501717E925F2A99ABEA22246F5F3CBA9AFC56FF28C73AF0DC4DF1BC693612D2ABD595B10523F9B9DEE372C64D22775311FF552F9A31D1B8FE023490C216064DC71912241136ACFECE71AD0B1ECB2C1B4F4398B3290620584D3E4FD4904AA22C3F5B77FFE3FC1962D7F21F1641833500CF3F6644A613EA19D1AF412AADC1F56D2E5CED78119A76E9AF1F89DDFD7882B20046755CB29C1F99DDC37E5A9A7B79AB6B55A41BA94A4A6F9017A76C4091E797B6BA4B12116080D32475F577AF817458C307C07718D723873B1F5AB3B27904AFF0381D023B67FF681012F7B833D64E7148F11A3B027E7DC508FE8B44B431D913ABCA6AA775CEDA079F96E6705488C6FB9B146A1F31EBB31E7D9C98ECA674DC3C3EA7C9997DE4508ADEE7088446370DD69000EC38B86D7165E84D63C13B04BA96B240C49E2983E98C9E82DDD9BD38007E36C62F747912917437EA782E75D986B785EA142F61515A71BBA3DEB85811DDF280238DB89E287E4870AE53C4E1989D2A6D668F72A1ABB68D3DC7E000A95FBE64E7FC112808B134B380206A0A088BB2AC1DD7A8F17C224650935ECB08BA4B5993E1ED50B9CCFAD73149D04C168CD4E23643D12E286B70C7100A4133D3B282B016785A94182BF06C133D71879ACF065BC5EFD4B6ACA88DBE24156F54B90AB6738C26DECE1E00CCA2267A529FCB5283EF337685AEF3CFC930B94800024A6B92A9989ACFB41F3FEFD1778C60FFF0FD9FC571E2DF100946AF4FE4FDF29B0074A11A51DAAC9822D2961EF41DFC317291C7491D5932DC0D10C5B61A7BFFE90583A8FE22B9285860EEE760E58B6B7CF5211F5A329D3620EF60D9E66821C9743136FBB72C9A9D1CBD33B940E6FB1E9DF47B199CD3C2BE3761F97138CC4E003FC8422F62F78763650CF4D8E4DACC8BE60042D2B9BC86E555C2F8DB314D7C0454259D80214925D5E86C56E1B96C1F4685048989F985723619E810E8C782C55E48815FBB445BF162F16B7F5E3BA5B2A65F15777063D056A9A3003CC452BE92EC02335B42F7CC272087F22926346D9B4AB62D10CADAAA6492A21781EEEEF072CCE2E96988E3F05053F35FFB6B78EE49B208A6E943AE1C43625B798EB6B218021C76F1D7AEE8D1EF8507AB1CF6DEAD080155EE0FA9C8060F2C18024E4466EEBDBD3CFF865EEEBBA5363EDB3D9C8EB44B789577EEFE423AB20F3056410767D3478E70F5E33A928F9144D5392312219C06F7BDB7EF2C43ACE845CA6C93214E932E1D5C25A734969721A051719A1656B9033869410C97B8B97C4EDE2392695B6E995423C3F96ACB8044BB6425219BA6BE7A9D280A17285E47A8D8CACA1721EA3312E79190B98A446376B10CF12A92A75D39F1EA49F2C42C66EDBD7EA90402FBEB99BB078FCF8EFCDEBB77F40D6AEA7FE5EAAB7EF56E08629FC83E898D4D11E5B6B0EFC895CD703315F854188F9E138B247A9022694C881DF62168562C67EB263C28D5654C71DFEFCC9A0BFDC17372310291ECDDDF59599436657A2A04695F707EC5A50F6B655E26BABF8BC8A77DF4D707E65F47FD6B237ED946AE708D270A1ED39A19968446ACCFDF6C9691A46D3717067CC0F0512667113153B825847B3FE3F0451C2541ACEA44146238803FDF6AF339AEB9D4830FC31549582BC16DF2255DA109B7C28269647ADB4087D58F0633D7CBC730DDC1A92B3DD2735223D5AF840B0C9B654DADF54946525D57A4ADD70954AF45AA9B1FF04F005DB5946018321DFCE49FCE5F8C90E5FD22A406805F33D8A8FE8F31E3E49B2D2CA40E8966F03F2A434FA392ED513C9099CEDDA17F6D64C103CB12F0A336B4E5A9778742F4A2981A291DBD444DEBF9EE96BB491172D6E184A110E03E4C7C11D9F679749748C7D1F5AF5C1E39FB5B03126C0342D2BA5C0BAC40EF1C2CEF1997B2B18720442D0969F4F07F8D821C5B398F8B088B820B375333EAA4A283B04A6C086B9BC9BC85D45B7C90B6F393B105955D861F6D1FAEA49D8008B85A354744861B7516CC99D664E76E7EF653FB14498F302D77BF0DE7A5054A39BF3BB7579B560CB1A90C1002475998716B12A818B7357F47E72802F863FAC2430F6FA618A11A46163E16A102DB43AFE7F1852F4470BEFBD51F3A60CE7ED815C32CAC510BC5EE060AB4A4C51DC1CF9D0E0DCDC13802BB722ECD64A93362772A444275E2581FD1F46419E76FC5A14D3D3617748D5850391EE28AABDEE58DA564D4D064635DB7F54BB21C8E2773ECD88215A27F77968347A6A3A5C2656CB1374E885108E68D7075A21D5FEFA0533D55C483FC67D29CCE1BFE74BA0DAF3E0D28CB91BDD6D4757A529CF856A491DACABFE87A33252E54ECF26FFCE8A186EC89B0B3DCA8A821D08F9AFE474541D5FA716362AF7CCF33BB49773AC38D3065A241191C4869403BCF8ABBC0BF5197154AE1293CE608FBCCFF322A3218CBA1E2516D5E7F32C0468030BC78BDE4CAD2F798A9F906C9A79480EDD81F273B218D7EDE6FB3D4609553D94B323A8A89781E57011582BC0C5174A8A303F658E71C11DB092A0720B7A8187F0DEA0B228EC2A9222E17A050C24DD94CF882A614C0B57C1014A47FBBD8009484230B05E7C6A95C87245D84093A5A562D4619E034BE484532FD28E995E09306636AAB0A43C6199B29B5E1E6BBF0CD4BDBFE2FFCBB0DAE0A9678D06A0D16BD43530F7AA102FBC663BFCAC4B6D9FE3E4BB6D9346F56EEC7E5CA3A35BA06AE0117CEFF8EB96852F42041FBF6A54B9B1FF644F7CA63B2963E735EE18A99E5DC7B1A402F3CBB534F54986FF27CEA9C51C44EF6319A8BDC762484802130EF5688FC4155272D7723D94C3DB93EBBB5973AC99FDBBC840152BBEB3BD46023F62AA61547E5080C092D7ED9EA994EB15B6DF7A913122EF1EE748191F9049E578B217E47C79590D95138C9E8D2F08DAE909AAC1F036936EF9D29AF33FCA1DC3063FB506AADDE8645A5B0AABA6D2E1DD238EAABFCD326D20926ED274C5106B6910E7C8CE27447869F42C0091692C1BAE52D3330F1151A80F11A17BF2F34CD25FCB8BC9A92DDD2F5D62A02C534FDE43AFBC1B5403ABE08C6E1E74BAB74C86B67E8C11AFCF5522DDB7D4C86578AEDB9809E120220C107B816AEFA7262841559643B25E98BF1393063B514E871D7A9BD27D07BF2F482135A171C6902DF59F9DFE0CC7FA29EAD960A9711D9AB55F42F9666583D03E35EC8C99BE7C99EB16E4D2AE35BABBCC62C228D8975D7039C1AE99906B2FB11A555E2E43DF87BB250267F54EE6BB90341B588C47F6DA0FADCBD0CB5493E7102DFC3C2B16F856C6A2C9A6B8FA76871F40F48E6EBF4D1E1931AFF4EC350FB7123057D1000787D0F30E10A221804BA759BCB382F12FB2020BBA3F02D08065335260365DEAF8BC92DF5F1DD1E215B569BD7C453A7578C8E0E7F8885969BC0AC1BE3B5F1770E828CC5385632D79478C22AA687F714CFE6F001D32E73D6308941B30BB6D8B626E5F6F71C894236AFD9DF9726FC9AD6F58AFCC26AA25617E6FBDE0CE5D202B1E28AD7A9723F3440927DBBD8D0DD36C2D88D942FD4A8BDAA4A19A766CA7C3AD1047546D1568E769736B6E13CBD3B1EE08E00DB371C1FBE8CFF4A30D6B163A31BF6C30C2C872B7995BD08D2B2A831CC4842C5019860F25BCC4313F3D3E205D886DBB82EEDBC0B724CD02C3FDA31328AE17C611DD2D6BED0B68CB2F85C4BAC664DC52296291C5B69F3E09E6AF89EF68F21E1C692D9A846E97AD768F0F");
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test(expected=IllegalArgumentException.class)
	public void testHkdfMaxLengthPlusOne() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("00");
		final byte[] salt        = DatatypeConverter.parseHexBinary("00");
		final byte[] info        = DatatypeConverter.parseHexBinary("00");
		final int    length      = Mac.getInstance(hash, this.provider).getMacLength() * 255 + 1;
		final byte[] expectedPrk = null;
		final byte[] expectedOkm = null;
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@Test(expected=IllegalArgumentException.class)
	public void testHkdfEmptyPrk() throws Exception {
		final String hash        = "HmacSHA256";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("00");
		final byte[] salt        = DatatypeConverter.parseHexBinary("00");
		final byte[] info        = DatatypeConverter.parseHexBinary("00");
		final int    length      = 42;
		final byte[] expectedPrk = DatatypeConverter.parseHexBinary("");
		final byte[] expectedOkm = null;
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	private void testHkdfHelper(final String provider, final String hash, final byte[] ikm, final byte[] salt, final byte[] info, final int length, final byte[] expectedPrk, final byte[] expectedOkm) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, ShortBufferException, IllegalStateException {
		final byte[] actualExtractAndExpandOkm = HkdfUtil.hkdfExtractAndExpand(provider, hash, length, ikm, salt, info);
		final byte[] actualExtractOnlyPrk      = HkdfUtil.hkdfExtract(provider, hash, ikm, salt);
		final byte[] actualExpandOnlyOkm       = HkdfUtil.hkdfExpand(provider, hash, length, info, expectedPrk);

		final int expectedMacLength = Mac.getInstance(hash, provider).getMacLength();
		Assert.assertNotNull(actualExtractOnlyPrk);
		Assert.assertEquals(expectedMacLength, actualExtractOnlyPrk.length);	// Example: SHA-256 output is 256 bits or 32 bytes
		Assert.assertTrue("Expected Extract Only PRK: " + DatatypeConverter.printHexBinary(expectedPrk) + ", Actual: " + DatatypeConverter.printHexBinary(actualExtractOnlyPrk), MessageDigest.isEqual(expectedPrk, actualExtractOnlyPrk));	// Constant time byte array compare prevents length time attack

		Assert.assertNotNull(actualExpandOnlyOkm);
		Assert.assertEquals(length, actualExpandOnlyOkm.length);
		Assert.assertTrue("Expected Expand Only OKM: " + DatatypeConverter.printHexBinary(expectedOkm) + ", Actual: " + DatatypeConverter.printHexBinary(actualExpandOnlyOkm), MessageDigest.isEqual(expectedOkm, actualExpandOnlyOkm));	// Constant time byte array compare prevents length time attack

		Assert.assertNotNull(actualExtractAndExpandOkm);
		Assert.assertEquals(length, actualExtractAndExpandOkm.length);
		Assert.assertTrue("Expected Extract-And-Expand OKM: " + DatatypeConverter.printHexBinary(expectedOkm) + ", Actual: " + DatatypeConverter.printHexBinary(actualExtractAndExpandOkm), MessageDigest.isEqual(expectedOkm, actualExtractAndExpandOkm));	// Constant time byte array compare prevents length time attack
	}

//	private void testHkdfHelperExpandOnlyDiffLengthPrkHash(final String provider, final String hash, final byte[] ikm, final byte[] salt, final byte[] info, final int length, final byte[] expectedPrk, final byte[] expectedOkm) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, ShortBufferException, IllegalStateException {
//		final byte[] actualExpandOnlyOkm = HkdfUtil.hkdfExpand(provider, hash, length, info, expectedPrk);
//
//		Assert.assertNotNull(actualExtractOnlyPrk);
//		Assert.assertNotEquals(expectedMacLength, actualExtractOnlyPrk.length);	// Example: SHA-256 output is 256 bits or 32 bytes
//		Assert.assertTrue("Expected Extract Only PRK: " + DatatypeConverter.printHexBinary(expectedPrk) + ", Actual: " + DatatypeConverter.printHexBinary(actualExtractOnlyPrk), MessageDigest.isEqual(expectedPrk, actualExtractOnlyPrk));	// Constant time byte array compare prevents length time attack
//	}

	@Test
	public void testHkdfPerformance() throws Exception {
		final String hash        = "HmacSHA1";
		final byte[] ikm         = DatatypeConverter.parseHexBinary("000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f");
		final byte[] salt        = DatatypeConverter.parseHexBinary("606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeaf");
		final byte[] info        = DatatypeConverter.parseHexBinary("b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff");
		final int    length      = 82;
		final byte[] expectedPrk = DatatypeConverter.parseHexBinary("8adae09a2a307059478d309b26c4115a224cfaf6");
		final byte[] expectedOkm = DatatypeConverter.parseHexBinary("0bd770a74d1160f7c9f12cd5912a06ebff6adcae899d92191fe4305673ba2ffe8fa3f1a4e5ad79f3f334b3b202b2173c486ea37ce3d397ed034c7f9dfeb15c5e927336d0441f4c4300e2cff0d0900b52d3b4");
		this.testHkdfHelper(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);

		this.testHkdfPerformanceExtractAndExpand(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
		this.testHkdfPerformanceExtract			(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
		this.testHkdfPerformanceExpand			(this.provider, hash, ikm, salt, info, length, expectedPrk, expectedOkm);
	}

	@SuppressWarnings("unused")
	private void testHkdfPerformanceExtractAndExpand(final String provider, final String hash, final byte[] ikm, final byte[] salt, final byte[] info, final int length, final byte[] expectedPrk, final byte[] expectedOkm) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, ShortBufferException, IllegalStateException {
		for (int i=0; i<this.warmups; i++) {	// performance warm ups
			HkdfUtil.hkdfExtractAndExpand(provider, hash, length, ikm, salt, info);
		}
		try (Timer x = new Timer("hkdfExtractAndExpand-" + this.provider)) {	// performance samples
			for (int i=0; i<this.samples; i++) {
				HkdfUtil.hkdfExtractAndExpand(provider, hash, length, ikm, salt, info);
			}
		}
	}

	@SuppressWarnings("unused")
	private void testHkdfPerformanceExtract(final String provider, final String hash, final byte[] ikm, final byte[] salt, final byte[] info, final int length, final byte[] expectedPrk, final byte[] expectedOkm) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException {
		for (int i=0; i<this.warmups; i++) {	// performance warm ups
			HkdfUtil.hkdfExtract(provider, hash, ikm, salt);
		}

		try (Timer x = new Timer("hkdfExtract-" + this.provider)) {	// performance samples
			for (int i=0; i<this.samples; i++) {
				HkdfUtil.hkdfExtract(provider, hash, ikm, salt);
			}
		}
	}

	@SuppressWarnings("unused")
	private void testHkdfPerformanceExpand(final String provider, final String hash, final byte[] ikm, final byte[] salt, final byte[] info, final int length, final byte[] expectedPrk, final byte[] expectedOkm) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, ShortBufferException, IllegalStateException {
		for (int i=0; i<this.warmups; i++) {	// performance warm ups
			HkdfUtil.hkdfExpand(provider, hash, length, info, expectedPrk);
		}
		try (Timer x = new Timer("hkdfExpand-" + this.provider)) {	// performance samples
			for (int i=0; i<this.samples; i++) {
				HkdfUtil.hkdfExpand(provider, hash, length, info, expectedPrk);
			}
		}
	}
}